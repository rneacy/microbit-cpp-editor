export class Image {
    width: number;
    height: number;
    data: number[][]; // Values 0 - 255

    constructor(width: number, data: number[][]) {
        this.width = width;
        this.height = this.width;
        this.data = data;
    }

    setPixel(x: number, y: number, pix: number) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
        this.data[y][x] = Math.max(0, Math.min(255, pix)); // Ensure 0-255
    }

    getPixel(x: number, y: number) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return 0;
        return this.data[y][x];
    }

    shiftLeft(n: number) {
        n |= 1;

        this.data.forEach((row, y) => {
            row.forEach((_, x) => {
                this.setPixel(x, y, this.getPixel(x+n, y));
            });
        });
    }

    //! NOT WORKING
    shiftRight(n: number) {
        if(n===undefined) n = 1;

        this.data.forEach((row, y) => {
            for(let x = row.length - 1; x >= 0; x--) {
                this.setPixel(x, y, this.getPixel(x+n, y));
            }
        });
    }

    setPage(pg:number, bin:string[]) {
        let pageStart = 5 * pg;

        // Go through each row of the image (starting at the top).
        bin.forEach((rowVal, rowIndex) => {
            // Reverse through each row (not all rows are of WIDTH length, so stop when we hit the end and assume last part is 0).
            let pixels = rowVal.split('').slice(-5);
            if(pixels.length < 5) {
                let diff = 5 - pixels.length;
                for(let i = 0; i < diff; i++) {
                    pixels.unshift("0");
                }
            }

            pixels.forEach((pix, i) => {
                this.setPixel(
                    pageStart + i,
                    rowIndex, 
                    (pix==="1") ? 255:0
                );
            })
        });
    }

    isEmpty() {
        return !(!!this.data.filter(row => !!row.filter(pix => !!pix).length).length) // what is this LMAO
    }
}

export class FontData {
    // micro:bit font taken directly from CODAL.
    static readonly FONT = [0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x8, 0x8, 0x0, 0x8, 0xa, 0x4a, 0x40, 0x0, 0x0, 0xa, 0x5f, 0xea, 0x5f, 0xea, 0xe, 0xd9, 0x2e, 0xd3, 0x6e, 0x19, 0x32, 0x44, 0x89, 0x33, 0xc, 0x92, 0x4c, 0x92, 0x4d, 0x8, 0x8, 0x0, 0x0, 0x0, 0x4, 0x88, 0x8, 0x8, 0x4, 0x8, 0x4, 0x84, 0x84, 0x88, 0x0, 0xa, 0x44, 0x8a, 0x40, 0x0, 0x4, 0x8e, 0xc4, 0x80, 0x0, 0x0, 0x0, 0x4, 0x88, 0x0, 0x0, 0xe, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0x1, 0x22, 0x44, 0x88, 0x10, 0xc, 0x92, 0x52, 0x52, 0x4c, 0x4, 0x8c, 0x84, 0x84, 0x8e, 0x1c, 0x82, 0x4c, 0x90, 0x1e, 0x1e, 0xc2, 0x44, 0x92, 0x4c, 0x6, 0xca, 0x52, 0x5f, 0xe2, 0x1f, 0xf0, 0x1e, 0xc1, 0x3e, 0x2, 0x44, 0x8e, 0xd1, 0x2e, 0x1f, 0xe2, 0x44, 0x88, 0x10, 0xe, 0xd1, 0x2e, 0xd1, 0x2e, 0xe, 0xd1, 0x2e, 0xc4, 0x88, 0x0, 0x8, 0x0, 0x8, 0x0, 0x0, 0x4, 0x80, 0x4, 0x88, 0x2, 0x44, 0x88, 0x4, 0x82, 0x0, 0xe, 0xc0, 0xe, 0xc0, 0x8, 0x4, 0x82, 0x44, 0x88, 0xe, 0xd1, 0x26, 0xc0, 0x4, 0xe, 0xd1, 0x35, 0xb3, 0x6c, 0xc, 0x92, 0x5e, 0xd2, 0x52, 0x1c, 0x92, 0x5c, 0x92, 0x5c, 0xe, 0xd0, 0x10, 0x10, 0xe, 0x1c, 0x92, 0x52, 0x52, 0x5c, 0x1e, 0xd0, 0x1c, 0x90, 0x1e, 0x1e, 0xd0, 0x1c, 0x90, 0x10, 0xe, 0xd0, 0x13, 0x71, 0x2e, 0x12, 0x52, 0x5e, 0xd2, 0x52, 0x1c, 0x88, 0x8, 0x8, 0x1c, 0x1f, 0xe2, 0x42, 0x52, 0x4c, 0x12, 0x54, 0x98, 0x14, 0x92, 0x10, 0x10, 0x10, 0x10, 0x1e, 0x11, 0x3b, 0x75, 0xb1, 0x31, 0x11, 0x39, 0x35, 0xb3, 0x71, 0xc, 0x92, 0x52, 0x52, 0x4c, 0x1c, 0x92, 0x5c, 0x90, 0x10, 0xc, 0x92, 0x52, 0x4c, 0x86, 0x1c, 0x92, 0x5c, 0x92, 0x51, 0xe, 0xd0, 0xc, 0x82, 0x5c, 0x1f, 0xe4, 0x84, 0x84, 0x84, 0x12, 0x52, 0x52, 0x52, 0x4c, 0x11, 0x31, 0x31, 0x2a, 0x44, 0x11, 0x31, 0x35, 0xbb, 0x71, 0x12, 0x52, 0x4c, 0x92, 0x52, 0x11, 0x2a, 0x44, 0x84, 0x84, 0x1e, 0xc4, 0x88, 0x10, 0x1e, 0xe, 0xc8, 0x8, 0x8, 0xe, 0x10, 0x8, 0x4, 0x82, 0x41, 0xe, 0xc2, 0x42, 0x42, 0x4e, 0x4, 0x8a, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x8, 0x4, 0x80, 0x0, 0x0, 0x0, 0xe, 0xd2, 0x52, 0x4f, 0x10, 0x10, 0x1c, 0x92, 0x5c, 0x0, 0xe, 0xd0, 0x10, 0xe, 0x2, 0x42, 0x4e, 0xd2, 0x4e, 0xc, 0x92, 0x5c, 0x90, 0xe, 0x6, 0xc8, 0x1c, 0x88, 0x8, 0xe, 0xd2, 0x4e, 0xc2, 0x4c, 0x10, 0x10, 0x1c, 0x92, 0x52, 0x8, 0x0, 0x8, 0x8, 0x8, 0x2, 0x40, 0x2, 0x42, 0x4c, 0x10, 0x14, 0x98, 0x14, 0x92, 0x8, 0x8, 0x8, 0x8, 0x6, 0x0, 0x1b, 0x75, 0xb1, 0x31, 0x0, 0x1c, 0x92, 0x52, 0x52, 0x0, 0xc, 0x92, 0x52, 0x4c, 0x0, 0x1c, 0x92, 0x5c, 0x90, 0x0, 0xe, 0xd2, 0x4e, 0xc2, 0x0, 0xe, 0xd0, 0x10, 0x10, 0x0, 0x6, 0xc8, 0x4, 0x98, 0x8, 0x8, 0xe, 0xc8, 0x7, 0x0, 0x12, 0x52, 0x52, 0x4f, 0x0, 0x11, 0x31, 0x2a, 0x44, 0x0, 0x11, 0x31, 0x35, 0xbb, 0x0, 0x12, 0x4c, 0x8c, 0x92, 0x0, 0x11, 0x2a, 0x44, 0x98, 0x0, 0x1e, 0xc4, 0x88, 0x1e, 0x6, 0xc4, 0x8c, 0x84, 0x86, 0x8, 0x8, 0x8, 0x8, 0x8, 0x18, 0x8, 0xc, 0x88, 0x18, 0x0, 0x0, 0xc, 0x83, 0x60];

    // Font ASCII representation range.
    static readonly FONT_START = 32;
    static readonly FONT_END   = 126;

    static readonly FONT_WIDTH = 5;
    static readonly FONT_HEIGHT = 5;

    static textToImage(text:string) {
        text = text.trimEnd();
        let imgw = (this.FONT_WIDTH * text.length) + this.FONT_WIDTH;
        //let imgw = this.FONT_WIDTH * text.length;
        let img = new Image(imgw, Array(this.FONT_HEIGHT).fill(0).map(() => Array(imgw).fill(0)));

        let firstPage = ["0","0","0","0","0"];
        img.setPage(0, firstPage);

        text.split('').forEach((char, i) => {
            // Get the ASCII representation of this char and find the starting location in the font bytes.
            let ascii = char.charCodeAt(0);
            let dataSectionStart = (ascii - this.FONT_START) * this.FONT_WIDTH;

            // Now that we have the starting location, extract the 5 relevant bytes (and convert to binary).
            let charBytes = this.FONT.slice(dataSectionStart, dataSectionStart + this.FONT_WIDTH).map((byte) => byte.toString(2));

            // Include this char in the final image.
            img.setPage(i + 1, charBytes);
        });

        return img;
    }
}